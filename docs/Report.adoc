= CS2102 PROJECT TEAM 56
:site-section: Report
:toc:
:toc-title: Table Of Content
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL:

    LEOW JIT YONG (A0183105N)
    LIM WEI DONG (A0183105N)
    HOON CHEE PING (A0183105N)
    LEE EE JIAN (A0183105N)

== Introduction
The objective of the team project is to create a food delivery service application for the following stakeholders :

* Customers - Browse and place orders on food items from Restaurants

* Restaurants Staff - Receive, prepare orders from Consumers and manage food items in Restaurant.

* Delivery rider - Receive and deliver orders from Restaurants to Consumers

* Food Delivery Service (FDS) Manager - Manage operations of the application

The following sections will attempt to mainly explain the design considerations for the aforementioned application.

== Roles and Responsibilities

*Leow Jit Yong* - Fullstack Developer

*Lim Wei Dong* - Fullstack Developer

*Hoon Chee Ping* - Fullstack Developer

*Lee Ee Jian* - Fullstack Developer

== Application
=== Data Requirements and Constraints

The following are the data requirements and constraints for the various entities / relations in our project:

*Users* :

* Each user entity stores the userId, the user's name, and date of creation of account
* Each user is uniquely identifiable by userId (primary key)
* Each user must be one of : (i) Customer (ii) Restaurant Staff (iii) Rider (iv) FDS Manager

*Customers*

* The customer entity is a user, and stores the userId, name, date of creation of account, and credit card information for payment of orders
* Each customer is identified by userId (primary key) which is referenced from users (foreign key)

*Riders*

* The rider entity is a user, and stores the userId, name, date of creation of account, and the area he lives in
* The area attribute is used to  facilitate the application's assignment of orders to riders based on locality
* Each rider is identified by userId (primary key) which is referenced from users (foreign key)
* Each rider must be either : (i) Full-Time Rider (ii) Part-Time Rider

*Restaurant Staff*

* The restaurant staff entity is a user and stores the userId, name, date of creation of account
* Each restaurant staff is identified by userId (primary key) which is referenced from users (foreign key)
* Every restaurant staff must work in exactly one restaurant

*FDS Manager*

* The FDS manager entity is a user and stores the userId, name, date of creation of account
* Each FDS Manager is identified by userId (primary key) which is referenced from users (foreign key)

*Part-Time Rider*

* The part-time rider entity is a rider and stores the userId, name, date of creation of account
* Each part-time rider works on a weekly work schedule
* Each part-time rider is identified by userId (primary key) which is referenced from riders (foreign key)

*Full-Time Rider* //still need?

* The full-time rider entity is a rider and stores the userId, name, date of creation of account
* Each full-time rider works on a monthly work schedule
* Each full-time rider is identified by userId (primary key) which is referenced from riders (foreign key)

*Weekly Work Schedule (WWS)*

* The WWS entity stores the scheduleId, userId, start date and end date of the schedule.
* Each WWS is uniquely identifiable by it's scheduleId (primary key), and belongs to a specific rider which is referenced by userId (foreign key)

*Monthly Work Schedule (MWS)*

* The MWS is a weak entity consisting of 4 WWS, and stores the scheduleId of each WWS (scheduleId1, scheduleId2, scheduleId3, scheduleId4)
* Each MWS is uniquely identifiable by the 4 scheduleId of the WWS it consists of (primary key), which is referenced from the WWS(foreign key)

*Intervals*

* The interval entity stores the intervalId, scheduleId, start time and end time of interval
* Each interval is uniquely identifiable by intervalId
* Each interval must belong to exactly one WWS that is referenced by scheduleId (foreign key)

*Restaurant*

* The restaurant entity stores the restaurant name, area of locality, and a minimum order amount of any order to go through
* Each restaurant is uniquely identifiable by restaurant name
* Restaurants with the same name will have their location appended to thier restaurant name (e.g. Mac@WestCoastPark)

*Food*

* The food entity stores the food name and category of the food
* Each food is uniquely identified by its food name (primary key).
// must belong to at least some restaurant?

*Orders*

* The order entity stores the orderId, userId of the customer, the promotional code used, the restaurant name that the promo code is applicable to, the mode of payment by the customer, time of order being placed, delivery location, and reward points being used to offset the price
* Each order is uniquely identified by the orderId (primary key)
* Each order references the userId of the customer who created the order (foreign key)
* Each order references the promo code, together with the restaurant name that the promo code is applicable to (foreign key) to check if the promo code is valid
* Each order must be delivered exactly once by a rider

*Promotions*

* Each promotion entity stores the promo code of the promotion, the description, the creator of the promotion, the restaurant name it is applicable to, the unit of measurement of the discount, the rate of discount, and the start and end date of the promotion
* Each promotion is uniquely identifiable by the promo code coupled with the name of restaurant it is applicable to (primary key).
* For the same promo code, every restaurant that it is applicable to will be recorded in the promotions table. This facilitates the checking of the validity of use of the promo code

*CustomerPromotions* ?

* The customer promotions entity is a type of promotion, and stores the promo code, the restaurant name it is applicable to, and minimum time the customer last ordered from the restaurant.
* Each customer promotion is uniquely identified by the promo code coupled with the name of restaurant it is applicable to (primary key), which it references from Promotions (foreign key)


*MinSpendingPromotions* ?

* The customer promotions entity is a type of promotion, and stores the promo code, the restaurant name it is applicable to, and the minimum amount the customer must spend to receive the discount
* Each customer promotion is uniquely identified by the promo code coupled with the name of restaurant it is applicable to (primary key), which it references from Promotions (foreign key)

*Sells*

* Sells is a relation between restaurants and food, and stores the restaurant name, food name, the price, as well as the quantity that is available for each food
* Each sells relation is uniquely identified by the restaurant name coupled with the food name (primary key)
* The restaurant name is referenced from restaurants (foreign key), while the food name is referenced from the food (foreign key)

*Contains*

* Contains is an aggregate relation between the sells relation and Orders entity, and stores the orderId it belongs to, the restaurant name and food name of the food, the quantity of the food ordered, as wells as the review of the ordered food item
* For the same orderId, each food item being ordered will recorded in the contains table. This facilitates reviewing each food item individually, as well as keeping track of the quantity ordered per food item
* Each contains entry is uniquely identified by orderId,the restaurant name and food name (primary key)
* The restaurant and food name is referenced by the sells relation (foreign key), and the orderId is referenced from the orders entity

*Delivers*

* Delivers is a relation between riders and orders, and stores the orderId for the order being delivered, the userId of the rider, the time he departs for the restaurant, the time he arrives at the restaurant, the time he leaves the restaurant, the delivery time to the customer, and the rating received for the delivery
* Each deliver is uniquely identified by orderId since every order must be delivered exactly once (primary key), and references rider for userId (foreign key)


=== Functionalities

The FDS application fulfils the following functionalities:
[cols="3,40"]
|========
a|Customers | - Create / Update / Delete account

            - View his / her monthly statistics : (i) past orders (ii) past reveiws on orders

            - Browse / Search for food items by (i) name (ii) food category (iii) restaurant


a|Restaurant Staff | - Create / Update / Delete account

                - View his / her monthly statistics : (i) Total number of completed orders

(ii) Total cost of all completed orders
(excluding delivery fees)

(iii) Top 5 favorite food items (in terms of the number of orders
for that item).

- View details of created promotions: (i) Duration (in terms of the number of days/hours) of the
campaign

(ii) Average number of orders received during the promotion


a|Delivery Riders| - Create / Update / Delete account (Full-time OR Part-time)

                    - Declare their monthly schedule (Full-time) or weekly schedule (Part-time)

                    - View his / her monthly statistics ((i) Orders delievered (ii) Hours worked (iii) Ratings received (iv) Salary earned (v) time taken to deliver food)

a|FDS Manager| - View monthly summary information for each Customers:

(i) Total number of new customers

(ii) Total number of orders

(iii) Total cost of all orders

- View monthly summary information for each Rider:

(i) Total number of orders delivered by the rider fo

(ii) Total number of hours worked by the rider

(iii) Total salary earned by the rider

(iv) Average delivery time by the rider

(v) Ratings received by the rider for all the orders delivered

(vi) Average rating received by the rider for all the orders delivered

- View monthly summary information for Deliveries:

(i) For each hour and for each delivery location area, the total number of orders placed at that
hour for that location area.

|========

=== Interesting / Non-trivial Functions

?

== ER Model
=== Design considerations

(1) Promotions as an ISA relation to all sub promotions. By abstracting out attributes that are common to all promotions, we are able to achieve extensibility for promotions. This means it is easy to extend promotions and create more sub promotions. Restaurant Staff or the FDS Managers are able to create new types of sub promotions by identifying unique attributes which the sub promotion is based off.

By abstracting out key attributes of the promotion, different restaurants can now also create the same type of promotion but with the ability to customise it to their needs e.g. start and end date, rate of discount etc, different types of discount (Free delivery, %X Off, $X off, etc) and different promotion requirement (Spend a minimum of $10, Customer's last ordered delivery is 30 days ago)

(2)

=== Constraints not captured by ER Model

== Database Relational Schema
Users: BCNF
[source,SQL]
----
CREATE TABLE Users (
    userId 	     SERIAL,
    name		VARCHAR(100),
    PRIMARY KEY (userId)
);

Non-trivial FDs F = {userId → name}
----


Restaurants: BCNF
[source,SQL]
----
CREATE TABLE Restaurants (
    rname 		VARCHAR(200),
    minOrderAmt	   NUMERIC(8, 2),
    area 		 VARCHAR(20),
    PRIMARY KEY (rname),
    CHECK(area = 'central' OR
        area = 'west' OR
        area = 'east' OR
        area = 'north' OR
        area = 'south')
);

Non-trivial FDs F = {rname → (minOrderAmt)(area)}
----
Food schema : BCNF
[source,SQL]
----
CREATE TABLE Food (
    fname 		VARCHAR(20),
    category 	     VARCHAR(20) NOT NULL,
    PRIMARY KEY (fname),
    CHECK (category = 'western' OR
        category = 'chinese' OR
        category = 'japanese' OR
        category = 'korean' OR
        category = 'fusion')
);

Non-trivial FDs F = {fname → category}
----
Sells schema : BCNF
[source,SQL]
----
CREATE TABLE Sells (
    rname 		VARCHAR(20) REFERENCES Restaurants
                            on DELETE CASCADE
                            on UPDATE CASCADE,
    fname 		VARCHAR(20) REFERENCES Food
                            on DELETE CASCADE
                            on UPDATE CASCADE,
    price 		NUMERIC(8, 2) NOT NULL,
    availability 	INTEGER DEFAULT 10,
    PRIMARY KEY (rname, fname)
);

Non-trivial FDs F = {(fname)(rname) → (price)(availability)}
----
Restaurant Staff schema : BCNF
[source,SQL]
----
CREATE TABLE Restaurant_Staff (
    userId 		INTEGER,
    rname		  VARCHAR(20) REFERENCES Restaurants
                            on DELETE CASCADE
                            on UPDATE CASCADE,
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Users
                            on DELETE CASCADE
                            on UPDATE CASCADE
);

Non-trivial FDs F = {userId → rname}
----
FDS Manager schema : BCNF
[source,SQL]
----
CREATE TABLE FDS_Managers (
	userId 		INTEGER,
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Users
    			on DELETE CASCADE
			    on UPDATE CASCADE
);

Non-trivial FDs F = {0}
----
Customers schema : BCNF
[source,SQL]
----
CREATE TABLE Customers (
    userId 		INTEGER,
    creditCardInfo	 VARCHAR(100),
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Users
                            on DELETE CASCADE
                            on UPDATE CASCADE
);

Non-trivial FDs F = {userId → creditCardInfo}
----
Riders schema : BCNF
[source,SQL]
----
CREATE TABLE Riders (
    userId 		INTEGER,
    area 		  VARCHAR(20) NOT NULL,
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Users
                            on DELETE CASCADE
                            on UPDATE CASCADE,
    CHECK(area = 'central' OR
        area = 'west' OR
        area = 'east' OR
        area = 'north' OR
        area = 'south')
);

Non-trivial FDs F = {userId → area}
----
Part-time schema : BCNF
[source,SQL]
----
CREATE TABLE Part_Time
(
    userId               INTEGER,
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Riders
                            on DELETE CASCADE
                            on UPDATE CASCADE
    --        DEFERRABLE INITIALLY DEFERRED
);

Non-trivial FDs F = {0}
----
Weekly Work Schedules (WWS) schema : BCNF
[source,SQL]
----
CREATE TABLE Weekly_Work_Schedules
(
    scheduleId              SERIAL,
    userId                  INTEGER,
    startDate               TIMESTAMP,
    endDate                 TIMESTAMP,
    PRIMARY KEY (scheduleId),
    FOREIGN KEY (userId) REFERENCES Riders (userId),
        check ((endDate::date - startDate::date) = 6)
);

Non-trivial FDs F = {scheduleId → (userId)(startDate)(endDate)}
----
Monthly Work Schedules (MWS) schema : BCNF
[source,SQL]
----
CREATE TABLE Monthly_Work_Schedules (
    scheduleId1             INTEGER REFERENCES Weekly_Work_Schedules
                                    ON DELETE CASCADE,
    scheduleId2             INTEGER REFERENCES Weekly_Work_Schedules
                                    ON DELETE CASCADE,
    scheduleId3             INTEGER REFERENCES Weekly_Work_Schedules
                                    ON DELETE CASCADE,
    scheduleId4             INTEGER REFERENCES Weekly_Work_Schedules
                                    ON DELETE CASCADE,
    PRIMARY KEY (scheduleId1, scheduleId2, scheduleId3, scheduleId4)
);

Non-trivial FDs F = {scheduleId1 → (scheduleId2)(scheduleId3)(scheduleId4)
                    scheduleId2 → (scheduleId1)(scheduleId3)(scheduleId4)
                    scheduleId3 → (scheduleId1)(scheduleId2)(scheduleId4)
                    scheduleId4 → (scheduleId1)(scheduleId2)(scheduleId3)}
----
Intervals schema : BCNF
[source,SQL]
----
CREATE TABLE Intervals
(
    intervalId              SERIAL,
    scheduleId              INTEGER,
    startTime               TIMESTAMP,
    endTime                 TIMESTAMP,
    PRIMARY KEY (intervalId),
    FOREIGN KEY (scheduleId) REFERENCES Weekly_Work_Schedules (scheduleId)
                                ON DELETE CASCADE,
        check (DATE_PART('minutes', startTime) = 0
        AND
           DATE_PART('seconds', startTime) = 0
        AND
           DATE_PART('minutes', endTime) = 0
        AND
           DATE_PART('seconds', startTime) = 0
        AND
           DATE_PART('hours', endTime) - DATE_PART('hours', startTime) <= 4
        AND
           startTime::date = endTime::date
        AND
           DATE_PART('hours', endTime) > DATE_PART('hours', startTime)
        AND
           startTime::time >= '10:00'
        AND
           endTime::time <= '22:00'
        )
);

Non-trivial FDs F = {intervalId → (scheduleId)(startTime)(endTime)}
----
Promotions schema : BCNF
[source,SQL]
----
CREATE TABLE Promotions (
    promoCode	    VARCHAR(20),
    promoDesc 	   VARCHAR(200),
    createdBy	    VARCHAR(50), --?
    applicableTo	 VARCHAR(200) REFERENCES Restaurants(rname)
                                        ON DELETE CASCADE,
    discUnit	     VARCHAR(20) NOT NULL,
    discRate	     VARCHAR(20) NOT NULL,
    startDate	    TIMESTAMP NOT NULL,
    endDate	      TIMESTAMP NOT NULL,
    PRIMARY KEY (promoCode, applicableTo)
);


Non-trivial FDs F = {(promoCode)(applicableTo) → (promoDesc)(createdBy)(discUnit)
                                                    (discRate)(startDate)(endDate)}

----
Orders schema : BCNF
[source,SQL]
----
CREATE TABLE Orders (
    orderId 	    INTEGER,
    userId              INTEGER NOT NULL REFERENCES Customers ON DELETE CASCADE ON UPDATE CASCADE,
    promoCode	   VARCHAR(20),
    applicableTo        VARCHAR(200),
    modeOfPayment       VARCHAR(10) NOT NULL,
    timeOfOrder	 TIMESTAMP NOT NULL,
    deliveryLocation    VARCHAR(100) NOT NULL,
    usedRewardPoints    INTEGER DEFAULT 0,
    givenRewardPoints   INTEGER NOT NULL,
    PRIMARY KEY(orderId),
    FOREIGN KEY(promoCode, applicableTo)  REFERENCES Promotions,
    CHECK(modeOfPayment = 'cash' OR
          modeOfPayment ='credit')
);

Non-trivial FDs F = {orderId → (userId)(promoCode)(applicableTo)
                                (modeOfPayment)(timeOfOrder)(deliveryLocation)
                                (usedRewardPoints)(givenRewardPoints)}
----
Contains schema : BCNF
[source,SQL]
----
CREATE TABLE Contains (
    orderId 		INTEGER REFERENCES Orders
                                    ON DELETE CASCADE
                                    ON UPDATE CASCADE,
    rname		    VARCHAR(100),
    fname 		   VARCHAR(100),
    foodQty		  INTEGER NOT NULL,
    reviewContent            VARCHAR(300),
    PRIMARY KEY(orderId, rname, fname),
    FOREIGN KEY(rname, fname) REFERENCES Sells(rname, fname),
    CHECK(foodQty >= 1)
);

Non-trivial FDs F = {(orderId)(rname)(fname) → (foodQty)(reviewContent)}

----
Delivers schema : BCNF
[source,SQL]
----
CREATE TABLE Delivers (
    orderId                  INTEGER REFERENCES Orders
                                    ON DELETE CASCADE
                                    ON UPDATE CASCADE,
    userId                   INTEGER NOT NULL,
    departTimeForRestaurant  TIMESTAMP,
    departTimeFromRestaurant TIMESTAMP,
    arrivalTimeAtRestaurant  TIMESTAMP,
    deliveryTimetoCustomer   TIMESTAMP,
    rating	           INTEGER,
    PRIMARY KEY (orderId),
    FOREIGN KEY (userId) REFERENCES Riders
                            ON DELETE CASCADE,
    CHECK(rating <= 5)
);

Non-trivial FDs F = {(orderId) → (userId)(departTimeForRestaurant)(departTimeFromRestaurant)
                                    (arrivalTimeAtRestaurant)(deliveryTimetoCustomer)(rating)}

----
MinSpendingPromotions schema : BCNF
[source,SQL]
----
CREATE TABLE MinSpendingPromotions (
    promoCode	   VARCHAR(20),
    applicableTo	VARCHAR(200),
    minAmt	      NUMERIC(8, 2) DEFAULT 0,
    PRIMARY KEY (promoCode, applicableTo),
    FOREIGN KEY (promoCode, applicableTo) REFERENCES Promotions
                                            ON DELETE CASCADE
                                            ON UPDATE CASCADE
);

Non-trivial FDs F = {(promoCode)(applicableTo) → minAmt}

----
CustomerPromotions schema : BCNF
[source,SQL]
----
CREATE TABLE CustomerPromotions (
    promoCode	      VARCHAR(20),
    applicableTo	   VARCHAR(200),
    minTimeFromLastOrder   INTEGER, -- # of days
    PRIMARY KEY (promoCode, applicableTo),
    FOREIGN KEY (promoCode, applicableTo) REFERENCES Promotions
                                            ON DELETE CASCADE
                                            ON UPDATE CASCADE
);

Non-trivial FDs F = {(promoCode)(applicableTo) → minTimeFromLastOrder}

----
=== Constraints not captured by Relational Schema

*Intervals* - For the same rider, no intervals should overlap with one another. There must be at least 1 hour of break between any 2 consecutive intervals. Intervals must fall within the start and end date of the WWS they belong to.

*Weekly Work Schedule* - For each worker, there should be no overlapping WWS. Each WWS must be at least 10 hours and at most 48 hours in total. Each WWS must be declared for exactly 7 consecutive days.

*Monthly Work Schedule* - For each week in of the MWS, the 4 comprising WWS must be equivalent. Each WWS should have 5 consecutive work days, that comprise of intervals using the pre-defined shifts for full-time riders. Each MWS should last for 28 days exactly, and there should not be any overlapping MWS for the same rider.

*Promotions* - Every promotion applied to an order has to be checked that it fulfils the promotions constraints such as the minAmount as well as timelastOrdered

*Riders* - During the operation hours of the FDS, there should be at least five riders (part-time or full-time) working at each hourly interval.

*Orders* - Quantity of food ordered for a particular food item cannot exceed it's availability. Total cost order must hit a certain minimum order amount set by the restaurant.

== Triggers
=== Ensure No Overlap Between Intervals
Trigger: interval_overlap_trigger

Function called: check_intervals_overlap_deferred()

This trigger makes sure that within a same schedule which belongs to only one rider, there must not exist an overlap of different intervals.
This is a different implementation from the `OVERLAPS` operator provided by PSQL. The `OVERLAPS` operator does not consider intervals with a single common endpoint to overlap but our implementation does, in order to better fit our use case.

This is done by ensuring:

* For two intervals belonging to the same schedule and falls on the same date, they do not have any properties of a wrong input schedule.

[source,SQL]
----
CREATE OR REPLACE FUNCTION check_intervals_overlap_deferred() RETURNS TRIGGER AS
$$
DECLARE
    badInputSchedule INTEGER;
BEGIN
    SELECT DISTINCT I1.scheduleId
    INTO badInputSchedule
    FROM Intervals I1
    WHERE EXISTS(
                  SELECT 1
                  FROM Intervals I2
                  WHERE I2.scheduleId = I1.scheduleId
                    AND I2.intervalId <> I1.intervalId
                    AND I2.startTime::date = I1.startTime::date
                    AND (
                          (I2.startTime::time <= I1.startTime::time
                              AND I2.endTime::time >= I1.startTime::time)
                          --IE: I2 is 2-5pm , I1 is 3 - 4pm / 3 - 6pm
                          OR
                          (I2.startTime::time <= I1.endTime::time
                              AND I2.endTime::time >= I1.endTime::time)
                          --IE: I2 is 2-5pm, I1 is 12pm - 3pm / 12pm - 6pm
                          OR (
                                      DATE_PART('hours', I1.startTime) - DATE_PART('hours', I2.endTime) < 1
                                  AND DATE_PART('hours', I1.startTime) >= DATE_PART('hours', I2.endTime)
                            -- IE: I1 : 3-5pm, I2 is 11am - 2.30pm  (this constraint of one hour difference is also capture in schema)
                              )
                      )
              );
    IF badInputSchedule IS NOT NULL THEN
        RAISE EXCEPTION 'scheduleId % has some overlapping intervals', badInputSchedule;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE PLPGSQL;


CREATE CONSTRAINT TRIGGER interval_overlap_trigger
    AFTER INSERT
    ON Intervals
    DEFERRABLE INITIALLY DEFERRED
    FOR EACH ROW
EXECUTE FUNCTION check_intervals_overlap_deferred();
----

=== Ensure 5 Consecutive Days In Each WWS of a MWS
Trigger: mws_5days_trigger

Function: check_mws_5days_consecutive_constraint_deferred()

This is to enforce the constraint of “Each WWS in a MWS must consist of five consecutive work days”. The trigger makes sure that all intervals in a week (7 days) of the MWS selected by a full-time rider are of five consecutive days. This means that every day within the five consecutive days are work days with valid intervals.

This is done by ensuring:

* there are 5 distinct days that can be obtained from the work intervals for each week
* the difference between the first interval and the last interval of work is 4 days , i.e. all intervals fall within 5 days.

[source,SQL]
----
DROP FUNCTION IF EXISTS check_mws_5days_consecutive_constraint_deferred() CASCADE;
CREATE OR REPLACE FUNCTION check_mws_5days_consecutive_constraint_deferred() RETURNS TRIGGER AS
$$
DECLARE
lastIntervalStartTime  TIMESTAMP;
firstIntervalStartTime TIMESTAMP;
distinctDates          INTEGER;
BEGIN
WITH curr_Intervals AS (
SELECT *
FROM Intervals I
WHERE I.scheduleId = NEW.scheduleId1
)
SELECT startTime
into lastIntervalStartTime
FROM curr_Intervals I
ORDER BY endTime DESC
LIMIT 1;

    WITH curr_Intervals AS (
        SELECT *
        FROM Intervals I2
        WHERE I2.scheduleId = NEW.scheduleId1
    )
    SELECT startTime
    into firstIntervalStartTime
    FROM curr_Intervals I
    ORDER BY endTime ASC
    LIMIT 1;

    WITH curr_Intervals AS (
        SELECT *
        FROM Intervals I3
        WHERE I3.scheduleId = NEW.scheduleId1
    )
    SELECT COUNT(DISTINCT I.startTime::date)
    into distinctDates
    FROM curr_Intervals I;
    IF ((lastIntervalStartTime::date - firstIntervalStartTime::date) <> 4 --all intervals within 5 days
        OR distinctDates <> 5) -- each day got interval
    THEN
        RAISE EXCEPTION 'MWS must have 5 consecutive work days';
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE PLPGSQL;



CREATE CONSTRAINT TRIGGER mws_5days_trigger
AFTER INSERT
ON Monthly_Work_Schedules
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE FUNCTION check_mws_5days_consecutive_constraint_deferred();
----

=== Ensure Intervals in MWS Follow Predefined Timings
Trigger: mws_predefined_interval_trigger

Function: check_mws_intervals_constraint_deferred()

This trigger enforces each work day to only consist of the predefined intervals for full-time riders (e.g. 10pm to 2pm, 3pm to 7pm). This is achieved by pairing intervals of the same day belonging to the same schedule to ensure that they follow the specified timings.

First, we join 2 Interval instances using the startTime of the intervals.
Then, we check:

* Each interval declared has a corresponding pair
* Intervals are 1 hour apart
* The first interval starts at 10am/11am/12pm/1pm
* Both intervals are 4 hours long

[source,SQL]
----
DROP FUNCTION IF EXISTS check_mws_intervals_constraint_deferred() CASCADE;
CREATE OR REPLACE FUNCTION check_mws_intervals_constraint_deferred() RETURNS TRIGGER AS
$$
DECLARE
    badInputSchedule INTEGER;
BEGIN
    WITH curr_Intervals AS (
        SELECT *
        FROM Intervals I
        WHERE I.scheduleId = NEW.scheduleId1
    ),
         Interval_Pairs (intervalId1, startTime1, endTime1, intervalId2, startTime2, endTime2) AS (
             select cI1.intervalId, cI1.startTime, cI1.endTime, cI2.intervalId, cI2.startTime, cI2.endTime
             from curr_Intervals cI1,
                  curr_Intervals cI2
             where cI1.startTime::date = cI2.startTime::date -- 2 intervals of the same day
               and cI1.startTime::time < cI2.startTime::time -- cI1 is the earlier timing, cI2 the later
         )
    SELECT S.scheduleId
    INTO badInputSchedule
    FROM Weekly_Work_Schedules S
    WHERE S.scheduleId = NEW.scheduleId1
      AND (
            NOT EXISTS( -- table is non-empty
                    select 1 from Interval_Pairs IP2 limit 1
                )
            OR
            EXISTS( --checks for any bad intervals
                    SELECT 1
                    FROM Interval_Pairs IP
                    WHERE (select count(*) from Interval_Pairs) <>
                          ((select count(*) from curr_Intervals) / 2) -- each interval has a pair
                       OR NOT (
                            IP.startTime1::time = '10:00' OR
                            IP.startTime1::time = '11:00' OR
                            IP.startTime1::time = '12:00' OR
                            IP.startTime1::time = '13:00'
                        )
                       OR NOT (DATE_PART('hours', IP.endTime1) - DATE_PART('hours', IP.startTime1) = 4
                        AND DATE_PART('hours', IP.endTime2) - DATE_PART('hours', IP.startTime2) = 4)

                       OR NOT (DATE_PART('hours', IP.startTime2) - DATE_PART('hours', IP.endTime1) = 1)
                )
        );

    IF badInputSchedule IS NOT NULL THEN
        RAISE EXCEPTION '% violates some timing in Intervals', badInputSchedule;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE PLPGSQL;


CREATE CONSTRAINT TRIGGER mws_predefined_interval_trigger
    AFTER INSERT
    ON Monthly_Work_Schedules
    DEFERRABLE INITIALLY DEFERRED
    FOR EACH ROW
EXECUTE FUNCTION check_mws_intervals_constraint_deferred();
----
== Complex Queries
=== View Monthly Salary for Rider

This query calculates the amount of salary that a rider (part-time or full-time) receives for the month. First we find the detailed schedule of the rider by joining the interval table with the weekly schedule table. 

The salary calculation is as such: 

Base salary + Bonus salary.
Base salary is calculated by: Number of hours worked * Rate per hour. Rate per hour is determined by whether the rider is a part-timer ($2/h) or full timer($5/h). 

Bonus salary is calculated by: Number of deliveries($4 per delivery) made during peak hour (Between the periods of 12:00 - 13:00 and 18:00 - 20:00) + Number of deliveries($2 per delivery) made during non-peak hour.

----
 WITH result AS (                                                                                                                      
        SELECT startTime, endTime, date_part('hours', endTime) - date_part('hours', startTime) AS duration                                
        FROM Weekly_Work_Schedules S JOIN intervals I                                                                                                     
        ON (S.scheduleId = I.scheduleId)                                                                                                  
        AND (S.userid = $1) AND (SELECT EXTRACT(MONTH FROM S.startDate::date)) = $2                                                       
        AND (SELECT EXTRACT(YEAR FROM S.startDate::date)) = $3), 
    result2 AS (
        SELECT D.deliveryTimetoCustomer, CASE 
                                        WHEN ((deliveryTimetoCustomer::time >= '12:00' AND deliveryTimetoCustomer::time <= '13:00')
                                                OR (deliveryTimetoCustomer::time >= '18:00' AND deliveryTimetoCustomer::time <= '20:00'))
                                        then 4
                                        else 2
                                        end as delivery_fee
        FROM Delivers D      
        WHERE userId = $1
        AND (SELECT EXTRACT(MONTH FROM D.deliveryTimetoCustomer::date)) = $2
        AND (SELECT EXTRACT(YEAR FROM D.deliveryTimetoCustomer::date)) = $3),
    result3 AS (
        SELECT coalesce((SELECT sum(duration) from result R),0) AS totalHoursWorked , coalesce(sum(delivery_fee),0) AS totalFees
        FROM result2 R2)
    SELECT R3.totalHoursWorked, R3.totalFees, CASE
        WHEN $1 NOT IN (select PT.userId from Part_Time PT) THEN (R3.totalHoursWorked * 5 + totalFees)
        ELSE (R3.totalHoursWorked * 2 + totalFees) --part_time
        end AS pay
    FROM result3 R3;
----


=== Check current status for Rider

This is a complex query to find the current status of the rider. 

All riders will be in three states:

* Rider is not working 
* Rider is working and free to accept orders.
* Rider is working and currently delivering orders.

First, we find the detailed schedule of all riders by joining the schedule table and interval table. We check whether he is working or he is on his break at this current time. If he is working, we would check again to see if he is currently delivering or not by checking the expected delivery time to the customer.


----
CREATE OR REPLACE FUNCTION findStatusOfRider(riderId INTEGER, current TIMESTAMP)
    RETURNS INTEGER AS
$$
DECLARE
    latestDelivery TIMESTAMP;
    result         INTEGER;

BEGIN
    SELECT D.deliveryTimetoCustomer
    INTO latestDelivery
    FROM Delivers D
    WHERE D.userId = riderId
    ORDER BY D.deliveryTimetoCustomer desc
    LIMIT 1;

    IF latestDelivery IS NULL THEN
        latestDelivery = '1970-01-01 00:00:00';
    END IF;

    CASE
        WHEN checkWorkingStatusHelperOfRider(riderId, current) = 0 then result = 0;
        WHEN latestDelivery < current THEN result = 1;
        WHEN current <= latestDelivery THEN result = 2;
        ELSE result = -1;
        END CASE;
    RETURN result;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION checkWorkingStatusHelperOfRider(riderId INTEGER, current TIMESTAMP)
    RETURNS INTEGER AS
$$
DECLARE
    currentDate DATE;
    currentTime TIME;
    result      INTEGER;

BEGIN
    currentTime = current::time;
    currentDate = current::date;

    CASE
        WHEN EXISTS(
                SELECT 1
                FROM Intervals I
                WHERE I.startTime::time <= currentTime
                  AND I.endTime::time > currentTime
                  AND I.startTime::date <= currentDate
                  AND I.endTIme::date <= currentDate
                  AND I.scheduleId = (SELECT W.scheduleId
                                      FROM Weekly_Work_Schedules W
                                      WHERE W.startDate::date <= currentDate
                                        AND W.endDate::date >= currentDate
                                        AND W.userId = riderId)
            ) THEN result = 1;
        ELSE result = 0;
        END CASE;
    RETURN result;
END;
$$ LANGUAGE PLPGSQL;
----

== Software tools / Frameworks
*Frontend* :

*Platform* : Node.js

*Framework* : Express.js

*Database* : PostgreSQL [v?]

*Languages used*

* Javascript

* SQL for database

== Application Screenshot

== Conclusion/Summary

One particularly challenging factor that we faced was coding out a full stack development which consists of the front-end, back-end and the database. As some of us are relatively new to PERN (PostgresSQL, Express, Node.js and React) stack development, we have to research a lot to find out how each of the technology works and how to make sure each of them can be used cohesive with each other. We also had some difficulties coming up with various complex queries and triggers for the system. At many times, the queries that we came up with did not generate what we wanted, hence, quite some time was spent on debugging.

At times, we were also unsure of what the best practices are when building the app. For example, there were cases where we were uncertain if we should implement a logic in the backend or if we should handle it in the database as both ways are possible. Furthermore, when we first started on the project, we were unsure of how to design a good schema, i.e. what kind of attributes we should include in the schema. These were gradually made clearer to us in the later part of the module after we were introduced with concepts like normal forms, which taught us some properties to take note of when evaluating a schema.

From this project, we learnt that it is very important to determine how you will evaluate your system before implementation. We managed to incorporate a design thinking iterative process throughout our project. As there are many different types of users and each user has different needs, hence the design thinking process helps us to understand each user and the needs. With this, we managed to understand the specification better.

The key takeaway was the valuable experience of coding out a database application. This project helps us to understand the importance of using a database in a system and how it is implemented in a real world setting. Apart from learning databases at a deeper level, we also learnt about other web development technologies which will be very useful to us in the future.
