= CS2102 PROJECT TEAM 56
:site-section: Report
:toc:
:toc-title: Table Of Content
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL:

    LEOW JIT YONG (A0183105N)
    LIM WEI DONG (A0183105N)
    HOON CHEE PING (A0183105N)
    LEE EE JIAN (A0183105N)

== Introduction
The objective of the team project is to create a food delivery service application for the following stakeholders :

* Customers - Browse and place orders on food items from Restaurants

* Restaurants - Receive and prepare orders from Consumers

* Delivery rider - Deliver orders from Restaurants to Consumers

* Food Delivery Service (FDS) Manager - Manage operations of the application

The following sections will attempt to mainly explain the design considerations for the aforementioned application.

== Roles and Responsibilities

*Leow Jit Yong* - Fullstack Developer

*Lim Wei Dong* - Fullstack Developer

*Hoon Chee Ping* - Fullstack Developer

*Lee Ee Jian* - Fullstack Developer

== Application
=== Data Requirements and Constraints

* Each user entity stores the userId, the user's name, and date of creation of account
* Each user is uniquely identifiable by userId (primary key)
* Each user must be one of : (i) Customer (ii) Restaurant Staff (iii) Rider (iv) FDS Manager
* Each customer/rider/restaurant staff/FDS manager is identified by userId (primary key) which is referenced from users (foreign key)
* Each customer entity is a user, stores userId and credit card information
* Each rider entity is a user, stores userId and the area he/she lives in
* Each rider must be either : (i) Full-Time Rider (ii) Part-Time Rider
* Each part-time rider works on a weekly work schedule (WWS)
* Each full-time rider works on a monthly work schedule (MWS)
* Each restaurant staff entity is a user, and stores userId and restaurant name he/she works for
* Every restaurant staff must work in exactly one restaurant
* Each FDS manager entity is a user and stores the userId
* Each restaurant entity stores the restaurant name, area of locality, and a minimum order amount of any order
* Each restaurant is uniquely identifiable by its restaurant name (primary key)
* Each food entity stores the food name and category of the food
* Each food is uniquely identified by its food name (primary key).
* Each food entity sold by a restaurant entity is captured in the Sells relation
* Each sells relation stores the restaurant name, food name, the price, and quantity available for each food
* Each sells relation is uniquely identified by the restaurant name coupled with the food name (primary key)
* Each sells relation references restaurant name from restaurants (foreign key) and food name from the food (foreign key)
* Each restaurant can create promotions for their menu items
* Each promotion entity stores the promo code, the description, the creator of the promotion, the restaurant name it is applicable to, the unit of measurement of the discount, the rate of discount, and the start and end date of the promotion
* Each promotion is uniquely identifiable by the promo code and the name of the restaurant it is applicable to (primary key).
* Each order entity stores the orderId, userId of the customer, the promotional code used, the restaurant name that the promo code is applicable to, the mode of payment by the customer, time of order being placed, delivery location, and reward points being used to offset the price
* Each order is uniquely identified by the orderId (primary key)
* Each order references the userId of the customer who created the order (foreign key)
* Each order references the promo code, together with the restaurant name that the promo code is applicable to (foreign key) from promotions entity
* Each order must be delivered exactly once by a rider
* Each delivers relation stores the orderId for the order being delivered, the userId of the rider, the time rider departs for the restaurant, the time rider arrives at the restaurant, the time rider leaves the restaurant, the delivery time to the customer, and the rating received for the delivery
* Each deliver is uniquely identified by orderId (primary key) referenced from orders (foreign key), and references rider for userId (foreign key)
* Each order contains food items from a single restaurant
* Each contains aggregate relation stores the orderId it belongs to, the restaurant name and food name of the food, the quantity of the food ordered, and the review for the specific food
* Each contains entry is uniquely identified by orderId,the restaurant name and food name (primary key)
* The restaurant and food name is referenced by the sells relation (foreign key), and the orderId is referenced from the orders entity (foreign key)
* Each Weekly Work Schedule (WWS) stores the scheduleId, userId of the rider, start date and end date of the schedule.
* Each WWS is uniquely identifiable by it's scheduleId (primary key), and belongs to a specific rider which is referenced by userId (foreign key)
* Each Monthly Work Schedule stores the scheduleId of 4 unique WWS scheduleId
* Each MWS is uniquely identifiable by the 4 scheduleId of the WWS it consists of (primary key), which is referenced from the WWS(foreign key)
* Each WWS is made up of work intervals
* Each interval entity stores the intervalId, scheduleId of the WWS it belongs to, start time and end time of interval
* Each interval is uniquely identifiable by intervalId (primary key), and must belong to exactly one WWS that is referenced by scheduleId (foreign key)


=== Functionalities

*Customer*

Each customer should be able to create and update their user account details.
When making an order, customers are able to browse for food items by (i) area (ii) restaurant (iii) food name (iv) food category.
Upon making their order, customers can apply promotion codes and rewards points to their order.
Finally, each customer should be able to view their past order history, and reviews of food items from restaurant menu.

*Restaurant Staff*

Each restaurant staff should be able to create and update their user account details.
Restaurant staff should be able to view and update their restaurant menu.
Restaurant staff should be able to create new promotions for their restaurant, and view summary information of previous promotions. This includes the duration of the promotion, the total cost of order received, and the total number of orders received during promotion period.
Finally, they should also be able to view a monthly summary for order information. This includes the total number of orders, the cost of the orders, as well as the top 5 food choices for the month.

*Riders*

Each rider should be able to create and update their account details.
Riders should be able to view their delivery history, as well as their work schedule history.
They should also be able to declare weekly work schedules (WWS) (for part-timers) or their monthly work schedules (MWS) (for full-timers). The schedules declared should be in line with the FDS policy requirements (e.g. between 10 and 48 hours each week).
Finally, they should be able to view summary information for a particular month. This includes total salary, delivery fees earned, hours worked, average rating, average delivery time, and number of deliveries for the month.

*FDS Manager*

Each FDS manager should be able to create and update their account details.
FDS managers should be able to register restaurants into the application.
FDS managers should also be able to view monthly summary information. This includes total number of new customers, total number of orders made, and the total cost of all orders.
FDS managers should also be able to view an hourly summary information. This includes the total number of orders for each location, and the number of riders for each interval.
Finally, FDS managers should be able to view the monthly summary information that individual customers and riders have access to.


=== Interesting / Non-trivial Functions


== ER Model
=== Design considerations

(1) Promotions as an ISA relation to all sub promotions. By abstracting out attributes that are common to all promotions, we are able to achieve extensibility for promotions. This means it is easy to extend promotions and create more sub promotions. Restaurant Staff or the FDS Managers are able to create new types of sub promotions by identifying unique attributes which the sub promotion is based off.

By abstracting out key attributes of the promotion, different restaurants can now also create the same type of promotion but with the ability to customise it to thier needs e.g. start and end date, rate of discount etc.

(2)

=== Constraints not captured by ER Model

== Database Relational Schema
Users: BCNF
[source,SQL]
----
CREATE TABLE Users (
    userId 	     SERIAL,
    name		VARCHAR(100),
    PRIMARY KEY (userId)
);

Non-trivial FDs F = {userId → name}
----


Restaurants: BCNF
[source,SQL]
----
CREATE TABLE Restaurants (
    rname 		VARCHAR(200),
    minOrderAmt	   NUMERIC(8, 2),
    area 		 VARCHAR(20),
    PRIMARY KEY (rname),
    CHECK(area = 'central' OR
        area = 'west' OR
        area = 'east' OR
        area = 'north' OR
        area = 'south')
);

Non-trivial FDs F = {rname → (minOrderAmt)(area)}
----
Food schema : BCNF
[source,SQL]
----
CREATE TABLE Food (
    fname 		VARCHAR(20),
    category 	     VARCHAR(20) NOT NULL,
    PRIMARY KEY (fname),
    CHECK (category = 'western' OR
        category = 'chinese' OR
        category = 'japanese' OR
        category = 'korean' OR
        category = 'fusion')
);

Non-trivial FDs F = {fname → category}
----
Sells schema : BCNF
[source,SQL]
----
CREATE TABLE Sells (
    rname 		VARCHAR(20) REFERENCES Restaurants
                            on DELETE CASCADE
                            on UPDATE CASCADE,
    fname 		VARCHAR(20) REFERENCES Food
                            on DELETE CASCADE
                            on UPDATE CASCADE,
    price 		NUMERIC(8, 2) NOT NULL,
    availability 	INTEGER DEFAULT 10,
    PRIMARY KEY (rname, fname)
);

Non-trivial FDs F = {(fname)(rname) → (price)(availability)}
----
Restaurant Staff schema : BCNF
[source,SQL]
----
CREATE TABLE Restaurant_Staff (
    userId 		INTEGER,
    rname		  VARCHAR(20) REFERENCES Restaurants
                            on DELETE CASCADE
                            on UPDATE CASCADE,
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Users
                            on DELETE CASCADE
                            on UPDATE CASCADE
);

Non-trivial FDs F = {userId → rname}
----
FDS Manager schema : BCNF
[source,SQL]
----
CREATE TABLE FDS_Managers (
	userId 		INTEGER,
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Users
    			on DELETE CASCADE
			    on UPDATE CASCADE
);

Non-trivial FDs F = {0}
----
Customers schema : BCNF
[source,SQL]
----
CREATE TABLE Customers (
    userId 		INTEGER,
    creditCardInfo	 VARCHAR(100),
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Users
                            on DELETE CASCADE
                            on UPDATE CASCADE
);

Non-trivial FDs F = {userId → creditCardInfo}
----
Riders schema : BCNF
[source,SQL]
----
CREATE TABLE Riders (
    userId 		INTEGER,
    area 		  VARCHAR(20) NOT NULL,
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Users
                            on DELETE CASCADE
                            on UPDATE CASCADE,
    CHECK(area = 'central' OR
        area = 'west' OR
        area = 'east' OR
        area = 'north' OR
        area = 'south')
);

Non-trivial FDs F = {userId → area}
----
Part-time schema : BCNF
[source,SQL]
----
CREATE TABLE Part_Time
(
    userId               INTEGER,
    PRIMARY KEY (userId),
    FOREIGN KEY (userId) REFERENCES Riders
                            on DELETE CASCADE
                            on UPDATE CASCADE
    --        DEFERRABLE INITIALLY DEFERRED
);

Non-trivial FDs F = {0}
----
Weekly Work Schedules (WWS) schema : BCNF
[source,SQL]
----
CREATE TABLE Weekly_Work_Schedules
(
    scheduleId              SERIAL,
    userId                  INTEGER,
    startDate               TIMESTAMP,
    endDate                 TIMESTAMP,
    PRIMARY KEY (scheduleId),
    FOREIGN KEY (userId) REFERENCES Riders (userId),
        check ((endDate::date - startDate::date) = 6)
);

Non-trivial FDs F = {scheduleId → (userId)(startDate)(endDate)}
----
Monthly Work Schedules (MWS) schema : BCNF
[source,SQL]
----
CREATE TABLE Monthly_Work_Schedules (
    scheduleId1             INTEGER REFERENCES Weekly_Work_Schedules
                                    ON DELETE CASCADE,
    scheduleId2             INTEGER REFERENCES Weekly_Work_Schedules
                                    ON DELETE CASCADE,
    scheduleId3             INTEGER REFERENCES Weekly_Work_Schedules
                                    ON DELETE CASCADE,
    scheduleId4             INTEGER REFERENCES Weekly_Work_Schedules
                                    ON DELETE CASCADE,
    PRIMARY KEY (scheduleId1, scheduleId2, scheduleId3, scheduleId4)
);

Non-trivial FDs F = {scheduleId1 → (scheduleId2)(scheduleId3)(scheduleId4)
                    scheduleId2 → (scheduleId1)(scheduleId3)(scheduleId4)
                    scheduleId3 → (scheduleId1)(scheduleId2)(scheduleId4)
                    scheduleId4 → (scheduleId1)(scheduleId2)(scheduleId3)}
----
Intervals schema : BCNF
[source,SQL]
----
CREATE TABLE Intervals
(
    intervalId              SERIAL,
    scheduleId              INTEGER,
    startTime               TIMESTAMP,
    endTime                 TIMESTAMP,
    PRIMARY KEY (intervalId),
    FOREIGN KEY (scheduleId) REFERENCES Weekly_Work_Schedules (scheduleId)
                                ON DELETE CASCADE,
        check (DATE_PART('minutes', startTime) = 0
        AND
           DATE_PART('seconds', startTime) = 0
        AND
           DATE_PART('minutes', endTime) = 0
        AND
           DATE_PART('seconds', startTime) = 0
        AND
           DATE_PART('hours', endTime) - DATE_PART('hours', startTime) <= 4
        AND
           startTime::date = endTime::date
        AND
           DATE_PART('hours', endTime) > DATE_PART('hours', startTime)
        AND
           startTime::time >= '10:00'
        AND
           endTime::time <= '22:00'
        )
);

Non-trivial FDs F = {intervalId → (scheduleId)(startTime)(endTime)}
----
Promotions schema : BCNF
[source,SQL]
----
CREATE TABLE Promotions (
    promoCode	    VARCHAR(20),
    promoDesc 	   VARCHAR(200),
    createdBy	    VARCHAR(50), --?
    applicableTo	 VARCHAR(200) REFERENCES Restaurants(rname)
                                        ON DELETE CASCADE,
    discUnit	     VARCHAR(20) NOT NULL,
    discRate	     VARCHAR(20) NOT NULL,
    startDate	    TIMESTAMP NOT NULL,
    endDate	      TIMESTAMP NOT NULL,
    PRIMARY KEY (promoCode, applicableTo)
);


Non-trivial FDs F = {(promoCode)(applicableTo) → (promoDesc)(createdBy)(discUnit)
                                                    (discRate)(startDate)(endDate)}

----
Orders schema : BCNF
[source,SQL]
----
CREATE TABLE Orders (
    orderId 	    INTEGER,
    userId              INTEGER NOT NULL REFERENCES Customers ON DELETE CASCADE ON UPDATE CASCADE,
    promoCode	   VARCHAR(20),
    applicableTo        VARCHAR(200),
    modeOfPayment       VARCHAR(10) NOT NULL,
    timeOfOrder	 TIMESTAMP NOT NULL,
    deliveryLocation    VARCHAR(100) NOT NULL,
    usedRewardPoints    INTEGER DEFAULT 0,
    givenRewardPoints   INTEGER NOT NULL,
    PRIMARY KEY(orderId),
    FOREIGN KEY(promoCode, applicableTo)  REFERENCES Promotions,
    CHECK(modeOfPayment = 'cash' OR
          modeOfPayment ='credit')
);

Non-trivial FDs F = {orderId → (userId)(promoCode)(applicableTo)
                                (modeOfPayment)(timeOfOrder)(deliveryLocation)
                                (usedRewardPoints)(givenRewardPoints)}
----
Contains schema : BCNF
[source,SQL]
----
CREATE TABLE Contains (
    orderId 		INTEGER REFERENCES Orders
                                    ON DELETE CASCADE
                                    ON UPDATE CASCADE,
    rname		    VARCHAR(100),
    fname 		   VARCHAR(100),
    foodQty		  INTEGER NOT NULL,
    reviewContent            VARCHAR(300),
    PRIMARY KEY(orderId, rname, fname),
    FOREIGN KEY(rname, fname) REFERENCES Sells(rname, fname),
    CHECK(foodQty >= 1)
);

Non-trivial FDs F = {(orderId)(rname)(fname) → (foodQty)(reviewContent)}

----
Delivers schema : BCNF
[source,SQL]
----
CREATE TABLE Delivers (
    orderId                  INTEGER REFERENCES Orders
                                    ON DELETE CASCADE
                                    ON UPDATE CASCADE,
    userId                   INTEGER NOT NULL,
    departTimeForRestaurant  TIMESTAMP,
    departTimeFromRestaurant TIMESTAMP,
    arrivalTimeAtRestaurant  TIMESTAMP,
    deliveryTimetoCustomer   TIMESTAMP,
    rating	           INTEGER,
    PRIMARY KEY (orderId),
    FOREIGN KEY (userId) REFERENCES Riders
                            ON DELETE CASCADE,
    CHECK(rating <= 5)
);

Non-trivial FDs F = {(orderId) → (userId)(departTimeForRestaurant)(departTimeFromRestaurant)
                                    (arrivalTimeAtRestaurant)(deliveryTimetoCustomer)(rating)}

----
MinSpendingPromotions schema : BCNF
[source,SQL]
----
CREATE TABLE MinSpendingPromotions (
    promoCode	   VARCHAR(20),
    applicableTo	VARCHAR(200),
    minAmt	      NUMERIC(8, 2) DEFAULT 0,
    PRIMARY KEY (promoCode, applicableTo),
    FOREIGN KEY (promoCode, applicableTo) REFERENCES Promotions
                                            ON DELETE CASCADE
                                            ON UPDATE CASCADE
);

Non-trivial FDs F = {(promoCode)(applicableTo) → minAmt}

----
CustomerPromotions schema : BCNF
[source,SQL]
----
CREATE TABLE CustomerPromotions (
    promoCode	      VARCHAR(20),
    applicableTo	   VARCHAR(200),
    minTimeFromLastOrder   INTEGER, -- # of days
    PRIMARY KEY (promoCode, applicableTo),
    FOREIGN KEY (promoCode, applicableTo) REFERENCES Promotions
                                            ON DELETE CASCADE
                                            ON UPDATE CASCADE
);

Non-trivial FDs F = {(promoCode)(applicableTo) → minTimeFromLastOrder}

----
=== Constraints not captured by Relational Schema

*Intervals* - For the same rider, no intervals should overlap with one another. There must be at least 1 hour of break between any 2 consecutive intervals. Intervals must fall within the start and end date of the WWS they belong to.

*Weekly Work Schedule* - For each worker, there should be no overlapping WWS. Each WWS must be at least 10 hours and at most 48 hours in total. Each WWS must be declared for exactly 7 consecutive days.

*Monthly Work Schedule* - For each week in of the MWS, the 4 comprising WWS must be equivalent. Each WWS should have 5 consecutive work days, that comprise of intervals using the pre-defined shifts for full-time riders. Each MWS should last for 28 days exactly, and there should not be any overlapping MWS for the same rider.

*Promotions* - Every promotion applied to an order has to be checked that it fulfils the promotions constraints such as the minAmount as well as timelastOrdered

*Riders* - During the operation hours of the FDS, there should be at least five riders (part-time or full-time) working at each hourly interval.

*Orders* - Quantity of food ordered for a particular food item cannot exceed it's availability. Total cost order must hit a certain minimum order amount set by the restaurant.

== Triggers
=== 1
=== 2
=== 3

== Complex Queries
=== 1
=== 2
=== 3

== Software tools / Frameworks
*Frontend* :

*Platform* : Node.js

*Framework* : Express.js

*Database* : PostgreSQL [v?]

*Languages used*

* Javascript

* SQL for database

== Application Screenshot

== Conclusion